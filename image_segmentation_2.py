# -*- coding: utf-8 -*-
"""Image Segmentation_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IRB5XhNiRzsd1t41pdpGPZ23EV0-w0b8
"""

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

class ImageSegmentation:
    def __init__(self, dataset_path):
        self.dataset_path = dataset_path
        self.images = self.load_dataset()

    def load_dataset(self):
        # Load all images in the dataset path
        images = []
        for file_name in os.listdir(self.dataset_path):
            img_path = os.path.join(self.dataset_path, file_name)
            img_gray = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
            img_color = cv2.imread(img_path)  # For Watershed
            if img_gray is not None and img_color is not None:
                images.append((file_name, img_gray, img_color))
            else:
                print(f"Error loading image: {file_name}")
        return images

    def display_image(self, image, title):
        plt.figure(figsize=(8, 8))
        plt.imshow(image, cmap='gray')
        plt.title(title)
        plt.axis('off')
        plt.show()

    def save_image(self, image, output_path):
        cv2.imwrite(output_path, image)

    def simple_threshold(self, image, threshold_value=127):
        _, thresh_binary = cv2.threshold(image, threshold_value, 255, cv2.THRESH_BINARY)
        return thresh_binary

    def adaptive_mean_threshold(self, image):
        return cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)

    def adaptive_gaussian_threshold(self, image):
        return cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

    def otsu_threshold(self, image):
        _, th_otsu = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        return th_otsu

    def region_growing_floodfill(self, image, seed, lo_diff=10, up_diff=10):
        flood_filled_image = image.copy()
        mask = np.zeros((image.shape[0] + 2, image.shape[1] + 2), np.uint8)
        cv2.floodFill(flood_filled_image, mask, seedPoint=seed, newVal=255, loDiff=(lo_diff,), upDiff=(up_diff,))
        return flood_filled_image

    def watershed_segmentation(self, image_color):
        gray = cv2.cvtColor(image_color, cv2.COLOR_BGR2GRAY)
        _, bin_img = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        bin_img = cv2.morphologyEx(bin_img, cv2.MORPH_OPEN, kernel, iterations=2)

        sure_bg = cv2.dilate(bin_img, kernel, iterations=3)
        dist = cv2.distanceTransform(bin_img, cv2.DIST_L2, 5)
        _, sure_fg = cv2.threshold(dist, 0.5 * dist.max(), 255, cv2.THRESH_BINARY)
        sure_fg = np.uint8(sure_fg)

        unknown = cv2.subtract(sure_bg, sure_fg)

        _, markers = cv2.connectedComponents(sure_fg)
        markers += 1
        markers[unknown == 255] = 0

        markers = cv2.watershed(image_color, markers)
        image_color[markers == -1] = [0, 0, 255]
        return image_color

    def apply_segmentation(self, choice, save_output=False, seed=None, lo_diff=10, up_diff=10):
        methods = {
            1: ('Simple Thresholding', lambda img_gray, _: self.simple_threshold(img_gray)),
            2: ('Adaptive Mean Thresholding', lambda img_gray, _: self.adaptive_mean_threshold(img_gray)),
            3: ('Adaptive Gaussian Thresholding', lambda img_gray, _: self.adaptive_gaussian_threshold(img_gray)),
            4: ("Otsu's Thresholding", lambda img_gray, _: self.otsu_threshold(img_gray)),
            5: ('Region Growing (Flood Fill)', lambda img_gray, _: self.region_growing_floodfill(img_gray, seed, lo_diff, up_diff)),
            6: ('Watershed Segmentation', lambda _, img_color: self.watershed_segmentation(img_color))
        }

        if choice in methods:
            method_name, method_func = methods[choice]
            output_dir = os.path.join(self.dataset_path, f"{method_name}_output")
            if save_output and not os.path.exists(output_dir):
                os.makedirs(output_dir)

            for file_name, img_gray, img_color in self.images:
                result = method_func(img_gray, img_color)
                if save_output:
                    output_path = os.path.join(output_dir, f"segmented_{file_name}")
                    self.save_image(result, output_path)
                else:
                    self.display_image(result, f"{method_name} - {file_name}")
            print(f"Segmentation applied to all images. Results {'saved to ' + output_dir if save_output else 'displayed.'}")
        else:
            print("Invalid choice. Please select a valid option.")


def main_menu():
    print("\nImage Segmentation Menu:")
    print("1. Simple Thresholding")
    print("2. Adaptive Mean Thresholding")
    print("3. Adaptive Gaussian Thresholding")
    print("4. Otsu's Thresholding")
    print("5. Region Growing (Flood Fill)")
    print("6. Watershed Segmentation")
    print("0. Exit")


if __name__ == "__main__":
    dataset_path = r'C:\Users\Anjali\Downloads\train_images'
    segmenter = ImageSegmentation(dataset_path)

    if segmenter.images:
        while True:
            main_menu()
            choice = input("Enter your choice (0 to exit): ")

            if choice == '0':
                print("Exiting the program. Goodbye!")
                break
            try:
                choice = int(choice)
                if choice in [1, 2, 3, 4, 5, 6]:
                    save = input("Do you want to save the results? (yes/no): ").strip().lower() == 'yes'
                    if choice == 5:
                        x = int(input("Enter seed point X-coordinate: "))
                        y = int(input("Enter seed point Y-coordinate: "))
                        lo_diff = int(input("Enter lower difference threshold: "))
                        up_diff = int(input("Enter upper difference threshold: "))
                        seed = (x, y)
                        segmenter.apply_segmentation(choice, save_output=save, seed=seed, lo_diff=lo_diff, up_diff=up_diff)
                    else:
                        segmenter.apply_segmentation(choice, save_output=save)
                else:
                    print("Invalid choice. Please select a number between 0 and 6.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    else:
        print("No images found in the dataset.")

